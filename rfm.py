import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from datetime import datetime

st.set_page_config(page_title="E-Commerce RFM Recovery Dashboard", layout="wide")

@st.cache_data
def load_data():
    df = pd.read_csv("data.csv", encoding='ISO-8859-1')
    df.dropna(subset=['CustomerID'], inplace=True)
    df = df[df['Quantity'] > 0]
    df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
    df['TotalPrice'] = df['Quantity'] * df['UnitPrice']
    return df

df = load_data()

# Sidebar filters
st.sidebar.header("🔍 Filters")
country_options = df['Country'].unique().tolist()
selected_country = st.sidebar.selectbox("Select Country", ['All'] + sorted(country_options))
start_date = st.sidebar.date_input("Start Date", df['InvoiceDate'].min().date())
end_date = st.sidebar.date_input("End Date", df['InvoiceDate'].max().date())

# Apply filters
if selected_country != 'All':
    df = df[df['Country'] == selected_country]
df = df[(df['InvoiceDate'] >= pd.to_datetime(start_date)) & (df['InvoiceDate'] <= pd.to_datetime(end_date))]

st.title("📊 Customer Segmentation & Recovery Insights")
st.markdown("""
This project leverages **RFM (Recency, Frequency, Monetary)** analysis to segment customers based on their shopping behavior. The goal is to provide valuable insights for **targeted marketing**, increase **customer retention**, and **recover lost revenue** by re-engaging at-risk customers.
""")

# RFM Analysis
snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)
rfm = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,
    'InvoiceNo': 'nunique',
    'TotalPrice': 'sum'
}).reset_index()
rfm.columns = ['CustomerID', 'Recency', 'Frequency', 'Monetary']

# RFM scoring
rfm['R_Score'] = pd.qcut(rfm['Recency'], 4, labels=[4,3,2,1]).astype(int)
rfm['F_Score'] = pd.qcut(rfm['Frequency'].rank(method='first'), 4, labels=[1,2,3,4]).astype(int)
rfm['M_Score'] = pd.qcut(rfm['Monetary'], 4, labels=[1,2,3,4]).astype(int)
rfm['RFM_Segment'] = rfm['R_Score'].astype(str) + rfm['F_Score'].astype(str) + rfm['M_Score'].astype(str)
rfm['RFM_Score'] = rfm[['R_Score', 'F_Score', 'M_Score']].sum(axis=1)

# Map segments
def segment_map(score):
    if score >= 9:
        return 'Champions'
    elif score >= 7:
        return 'Loyal Customers'
    elif score >= 5:
        return 'Potential Loyalists'
    else:
        return 'At Risk'

rfm['Segment'] = rfm['RFM_Score'].apply(segment_map)

# ============================
# SECTION 1: Visualizations
# ============================
with st.expander("📖 What do the Customer Segments Mean?"):
    st.markdown("""
    - 🏆 **Champions**: Recent, frequent, and high-spending customers — keep them engaged!
    - 💎 **Loyal Customers**: Consistently purchase, not necessarily recent — reward them!
    - 🌱 **Potential Loyalists**: Recent and promising — nurture them with offers!
    - ⚠️ **At Risk**: Haven’t purchased recently — send re-engagement nudges!
    """)

# 1. Segment Distribution
st.subheader("📊 Customer Segment Distribution")
st.markdown("""
The following pie chart shows how customers are distributed across various segments based on **Recency, Frequency, and Monetary** values. This segmentation allows for targeted strategies, such as sending re-engagement emails to 'At Risk' customers and offering rewards to 'Loyal' ones.
""")
seg_counts = rfm['Segment'].value_counts().reset_index()
seg_counts.columns = ['Segment', 'Count']  # Renaming for clarity

fig1 = px.pie(seg_counts, names='Segment', values='Count', title='Customer Segment Distribution')
st.plotly_chart(fig1, use_container_width=True)


# 2. Revenue by Segment
st.subheader("💰 Revenue Contribution by Customer Segment")
st.markdown("""
The bar chart below shows the total revenue generated by each customer segment. This helps prioritize marketing efforts for segments that generate the most revenue, such as targeting 'Loyal' customers with exclusive offers.
""")
seg_revenue = rfm.groupby('Segment')['Monetary'].sum().reset_index()
fig2 = px.bar(seg_revenue, x='Segment', y='Monetary', color='Segment',
              title='💰 Revenue Contribution by Customer Segment')
st.plotly_chart(fig2, use_container_width=True)

# 3. RFM Heatmap
st.subheader("🧠 RFM Behavior Heatmap")
st.markdown("""
The heatmap visualizes the relationship between **Recency** (R), **Frequency** (F), and **Monetary** (M) scores. It shows customer density across different RFM score combinations, helping identify which RFM clusters are most profitable or at risk.
""")
heatmap_data = rfm.pivot_table(index='R_Score', columns='F_Score', values='CustomerID', aggfunc='count')
fig3 = px.imshow(heatmap_data, text_auto=True, color_continuous_scale='Blues', title='🧠 RFM Behavior Heatmap')
st.plotly_chart(fig3, use_container_width=True)

# ============================
# SECTION 2: Recovery Simulation
# ============================
st.header("🚀 Revenue Recovery Simulation")

st.markdown("""
This section simulates how much revenue can be recovered by re-engaging **At Risk** customers. By offering discounts or reminders, businesses can attempt to win back lost customers and increase their revenue. The **recovery rate slider** allows you to simulate various scenarios of customer reactivation.
""")

at_risk = rfm[rfm['Segment'] == 'At Risk']
recovery_rate = st.slider("Estimated Recovery Rate (%)", 0, 100, 20)
avg_order_value = df['TotalPrice'].mean()
recovered_customers = int(len(at_risk) * recovery_rate / 100)
recovered_revenue = recovered_customers * avg_order_value

col1, col2 = st.columns(2)
col1.metric("Recovered Customers", recovered_customers)
col2.metric("Recovered Revenue (£)", f"{recovered_revenue:,.2f}")

# ============================
# SECTION 3: Data Table
# ============================
st.header("📋 Sample of RFM Table")
st.dataframe(rfm[['CustomerID', 'Recency', 'Frequency', 'Monetary', 'Segment']].head(10))

def convert_df(df):
    return df.to_csv(index=False).encode('utf-8')

csv = convert_df(rfm[['CustomerID', 'Recency', 'Frequency', 'Monetary', 'Segment']])

# Download Button
st.download_button(
    label="Download RFM Table as CSV",
    data=csv,
    file_name='rfm_table.csv',
    mime='text/csv',
)
st.markdown(
    """
    <hr style="margin-top: 50px;">
    <div style='text-align: center; font-size: 14px; color: gray;'>
        Made with ❤️ by <b>Saurabh Rajani</b>
    </div>
    """,
    unsafe_allow_html=True
)
